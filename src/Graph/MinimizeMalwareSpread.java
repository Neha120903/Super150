package Graph;

import ThreeHundred.MinimumTimeCollectApples;

import java.util.HashMap;

public class MinimizeMalwareSpread {

    public int minMalwareSpread(int [][]graph, int []initial)
    {
        DSU ds= new DSU();

        for (int i = 0; i <graph.length ; i++) {
            ds.Create(i);
        }
        for (int i = 0; i < graph.length ; i++) {
            for (int j = i+1; j <graph.length ; j++) {
                if(graph[i][j]==1)
                    ds.union(i,j);
            }
        }

        int c[]= new int[graph.length];
        for(int n:initial){
            c[ds.find(n)]++;  //har infected k re p frequency bhdadi taki ek re s ek hi infected ho vrna answer 0 ayega
        }
        int ans=-1;
        int anssize=-1;
        for (int i = 0; i <initial.length ; i++) {
            int node=ds.find(initial[i]);
            if(c[node]==1)
            {
                int currsize=ds.size(node);
                if(currsize>anssize)
                {
                    ans=initial[i];
                    anssize=currsize;
                }
                else if(currsize ==anssize)
                {
                    ans=Math.min(ans,initial[i]);
                    anssize=currsize;
                }
            }
        }
        if(ans==-1)//every dsu m more than one infected node h
        {
            ans=Integer.MAX_VALUE;
            for (int i = 0; i <initial.length ; i++) {
                ans=Math.min(initial[i],ans);
            }
            return ans;
        }
        return ans;
    }
    public class DSU{
        public class Node{
            int val;
            Node parent;
            int rank; //size
        }
        HashMap<Integer,Node>map= new HashMap<>();

        public void Create(int v){
            Node nn= new Node();
            nn.val=v;
            nn.parent=nn;
            nn.rank=1;
            map.put(v,nn);
        }

        public int find(int v)
        {
            Node nn=map.get(v);
            return find(nn).val;
        }
        private Node find(Node nn)
        {
            if(nn.parent==nn)
                return nn;
            return find(nn.parent);
        }

        public void union(int v1, int v2)
        {
            Node n1=map.get(v1);
            Node n2=map.get(v2);

            Node re1=find(n1);
            Node re2=find(n2);

            re1.parent=re2;
            re2.rank= re1.rank+re2.rank;
        }

        public int size(int v)
        {
            Node nn=map.get(v);
            return find(nn).rank;
        }
    }
}
